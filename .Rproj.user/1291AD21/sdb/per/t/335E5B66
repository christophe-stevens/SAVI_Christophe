{
    "collab_server" : "",
    "contents" : "# Copyright (c) 2014, 2015 the SAVI authors (see AUTHORS.txt).\n# Licensed under the BSD 3-clause license (see LICENSE.txt)\n\n######################\n# START SHINY SERVER #\n######################\n\nprint(\"server.R called\") # this is called when we start the shiny server on SAVI via $ sudo start shiny-server\n\nrm(list=ls())\n\n##################\n# SET OPTIONS    #\n# LOAD LIBRARIES #\n# SOURCE SCRIPTS #\n##################\n\n\n\n# max upload for files\noptions(shiny.maxRequestSize=512*1024^2) # Max upload 1/2 Gb\n\n# debugging option. Only set to true for debugging. MUST BE FALSE FOR LIVE USE\noptions(shiny.reactlog=FALSE)\n\n# old style progress bar - required since shiny v 0.14\nshinyOptions(progress.style = \"old\")\n\n# load the libraries we need\nlibrary(MASS)\nlibrary(mgcv)\nlibrary(knitr)\nlibrary(rmarkdown)\nlibrary(xtable)\n\n# source all the functions we need\nsource(\"scripts.R\")\nsource(\"scripts_GPfunctions.R\")\nsource(\"scripts_GAMfunctions.R\")\nsource(\"scripts_plots.R\")\nsource(\"scripts_tables.R\")\nsource(\"scripts_text.R\")\nsource(\"scripts_GAMBasedIndivAvefunctions.R\")\n\n###########################\n#                         #\n#      EVSI TAB           #\n#                         #\n###########################\nsource(\"./EVSI/loader.R\")\n\n\n###########################\n# TEST DATA               #\n# users can download this #\n# to try out the app      #\n###########################\n\n# contained in sysdata.rda\n\n\n\n###################\n# SERVER FUNCTION #\n###################\n\n\nshinyServer(\n\n  function(input, output, session) {\n\n    ##################################################################################################\n\n    #####################################\n    # CREATE NEW ENVIRONMENT 'cache'    #\n    # Initialise cached variable values #\n    #####################################\n\n    # `cache' is the environment unique to each user visit\n    # This is where we will save values that need to persist,\n    # and that can be picked up and included in the report\n\n    if(exists(\"cache\")) rm(cache, inherits = TRUE) # we shouldn't need this\n    cache <- new.env()\n\n    cache$savedSession <- 0\n    cache$nIterate <- 0\n    cache$nInt <- 0\n    cache$pEVPI <- NULL\n    cache$params <- NULL\n    cache$uploadedCosts <- NULL   # these are the costs that are uploaded\n    cache$uploadedEffects <- NULL # these are the effects that are uploaded\n    cache$modelledCosts <- NULL   # these are the costs that are modelled in the ind sim case\n    cache$modelledEffects <- NULL # these are the effects that are uploaded in the ind sim case\n    cache$costs <- NULL\n    cache$effects <- NULL\n    \n    ###########################\n    #                         #\n    #      EVSI TAB           #\n    #                         #\n    ###########################\n    cache$psaSampleList <- NULL  # this object will contains all the psa parameters from the imported file.\n    cache$scenarioList <- ScenarioList$new()  # assign DistributionList that contains main distribution and parameters. \n    cache$scenarioController <- NULL # this is the controller object of the chosen scenario\n    \n\n    cache$tableCEplane <- NULL\n    cache$tableNetBenefit <- NULL\n    cache$groupTable <- NULL\n    cache$tableEVPI <- NULL\n    cache$tablePSUB <- NULL\n    cache$tableEVPPI <- NULL\n    cache$ceac.obj <- NULL\n\n    cache$textCEplane1 <- NULL\n    cache$calcEvpiVal <- NULL\n    cache$incValueCosts <- NULL\n    cache$incValueEffects <- NULL\n    cache$namesDecisions <- NULL\n    cache$moreLessCosts <- NULL\n    cache$confIntCE025costs <- NULL\n    cache$confIntCE975costs <- NULL\n    cache$confIntCE025effects <- NULL\n    cache$confIntCE975effects <- NULL\n    cache$pCostsavingVal <- NULL\n    cache$pMorebenVal <- NULL\n    cache$iCERVal <- NULL\n    cache$pCEVal <- NULL\n\n    cache$counterAdd <- 0\n    cache$setStore <- vector(\"list\", 100) # up to 100 sets for the group inputs\n    cache$subsetEvpiValues <- NULL\n    cache$setStoreMatchEvpiValues <- NULL\n    cache$currentSelection <- NULL\n    cache$ceac.obj <- NULL\n\n    # assign null values to the about the model variables in the cache\n    cache$modelName <- NULL\n    cache$current <- NULL\n    cache$t3 <- NULL\n    cache$lambdaOverall <- 0\n    cache$effectDef <- NULL\n    cache$costDef <- NULL\n    cache$annualPrev <- 0\n    cache$horizon <- 0\n    cache$currency <- NULL\n    cache$unitBens <- NULL\n    cache$jurisdiction <- NULL\n\n    cache$indSim <- FALSE\n\n    ########################\n    # AUTOLOAD FOR TESTING #\n    ########################\n\n    # these three rows autoload values for testing purposes - to avoid having to load them manually. MS\n    # ###########\n    #     load.parameters <- function() read.csv(\"../test/parameters.csv\")\n    #     load.costs <- function() read.csv(\"../test/costs.csv\")\n    #     load.effects <- function() read.csv(\"../test/effects.csv\")\n    # ###########\n    # Or load an Rdata file\n    # load(\"adenoma.Rdata\", envir=cache) # auto load for testing purposes\n\n\n    ######################################################################################\n\n\n\n    ################################## TABS BELOW #########################################\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    ########################\n    # ABOUT YOUR MODEL TAB #\n    ########################\n\n    # Function that saves \"about the model\" variables to the cache if they are changed in the input.\n\n    observe({\n      cache$modelName <- input$modelName\n      cache$current <- input$current\n      cache$t3 <- input$t3\n      cache$lambdaOverall <- input$lambdaOverall\n      cache$effectDef <- input$effectDef\n      cache$costDef <- input$costDef\n      cache$annualPrev <- input$annualPrev\n      cache$horizon <- input$horizon\n      cache$currency <- input$currency\n      cache$unitBens <- input$unitBens\n      cache$jurisdiction <- input$jurisdiction\n      # cache$indSim <- input$indSim\n    })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    ####################\n    # IMPORT FILES TAB #\n    ####################\n\n    ### Parameters\n\n    #  Function that imports parameters\n    observe({\n      inFile <- input$parameterFile\n      if (is.null(inFile)) return(NULL)\n      dat <- read.csv(inFile$datapath, sep=input$sep, dec=input$dec, encoding = 'UTF-8')\n      cache$params <- dat\n      cache$nParams <- NCOL(dat)\n      cache$nIterate <- NROW(dat) # size of PSA\n      # EVSI\n      cache$psaSampleList <- PsaSampleList$new(dat)  # EVSI: create an object that store all psa columns and their properties. \n    })\n\n    # Function that checks sanity of parameter file\n    output$textCheckTabParams <- renderText({\n      x1 <- input$parameterFile\n      params <- cache$params\n      if (is.null(params)) return(NULL)\n\n      if (sum(is.na(params)) > 0) {\n        return(\"There are missing values - please check data and reload\")\n      }\n\n      if (!prod(unlist(c(lapply(params, function(x) {class(x) == \"numeric\" | class(x) == \"integer\"}))))) {\n        return(\"Not all columns are numeric - please check data and reload\")\n      }\n\n      if (sum(unlist(lapply(params, function(x) length(unique(x)) > 1 & length(unique(x)) < 5))) > 0) {\n        return(\"One or more columns contains too few (<5) unique values for EVPPI analysis\")\n      }\n      return(NULL)\n    })\n\n\n    ### Costs\n\n    #  Function that imports costs\n    observe({\n      inFile <- input$costsFile\n      if (is.null(inFile)) return(NULL)\n      dat <- read.csv(inFile$datapath, sep=input$sep2, dec=input$dec2, encoding = 'UTF-8')\n      cache$uploadedCosts <- cache$costs <- dat\n      cache$namesDecisions <- paste(1:ncol(dat), \") \", colnames(dat), sep=\"\") # defines the decision option names\n      cache$nInt <- NCOL(dat) # number of interventions\n\n    })\n\n    # Function that checks sanity of costs file\n    output$textCheckTabCosts <- renderText({\n      x2 <- input$costsFile\n\n      costs <- cache$uploadedCosts\n      if (is.null(costs)) return(NULL)\n\n      if (sum(is.na(costs)) > 0) return(\"There are missing values - please check data and reload\")\n\n      if (NCOL(costs) == 1) return(\"There must be at least two decision options.\n                                      If you have a single set of incremental\n                                   costs for a two-decision option problem,\n                                    either upload the absolute costs, or include a column of zeroes.\")\n\n      if (!prod(unlist(c(lapply(costs, function(x) {class(x) == \"numeric\" | class(x) == \"integer\"}))))) {\n        return(\"Not all columns are numeric - please check data and reload\")\n      }\n\n      return(NULL)\n    })\n\n\n    ### Effects\n\n    # Function that imports effects\n    observe({\n      inFile <- input$effectsFile\n      if (is.null(inFile)) return(NULL)\n\n      dat <- read.csv(inFile$datapath, sep=input$sep3, dec=input$dec3, encoding = 'UTF-8')\n      cache$uploadedEffects <- cache$effects <- dat\n    })\n\n    # Function that checks sanity of effects file\n    output$textCheckTabEffects <- renderText({\n      x3 <- input$effectsFile\n      effects <- cache$uploadedEffects\n      if (is.null(effects)) return(NULL)\n\n      if (sum(is.na(effects)) > 0) return(\"There are missing values - please check data and reload\")\n\n      if (NCOL(effects) == 1) return(\"There must be at least two decision options.\n                                    If you have a single set of\n                                      incremental effects for a two-decision option problem,\n                                     either upload the absolute effects, or include a column of zeroes.\")\n\n      if (!prod(unlist(c(lapply(effects, function(x) {class(x) == \"numeric\" | class(x) == \"integer\"}))))) {\n        return(\"Not all columns are numeric - please check data and reload\")\n      }\n\n      return(NULL)\n    })\n\n    # Function that checks that files have the right number of rows and columns\n    output$textCheckTab <- renderText({\n      x1 <- input$parameterFile\n      x2 <- input$costsFile\n      x3 <- input$effectsFile\n\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n\n      params <- cache$params\n      costs <- cache$uploadedCosts\n      effects <- cache$uploadedEffects\n      if(!((NROW(params) == NROW(costs)) & (NROW(effects) == NROW(costs)))) {\n        return(\"Loaded files have different numbers of rows - please check data and reload\")\n      }\n\n      if(NCOL(effects) != NCOL(costs)) {\n        return(\"Costs and effect have different numbers of columns - please check data and reload\")\n      }\n\n      return(NULL)\n\n    })\n\n\n    ### DOWNLOAD TEST FILES\n\n    # Download csv file\n    output$testParams <- downloadHandler(\n      filename = \"parameters.csv\",\n      content = function(file) {\n        write.csv(SAVI:::testParams, file, row.names = FALSE)\n      },\n      contentType = \"text/csv\"\n    )\n\n    output$testCosts <- downloadHandler(\n      filename = \"costs.csv\",\n      content = function(file) {\n        write.csv(SAVI:::testCosts, file, row.names = FALSE)\n      },\n      contentType = \"text/csv\"\n    )\n\n    output$testEffects <- downloadHandler(\n      filename = \"effects.csv\",\n      content = function(file) {\n        write.csv(SAVI:::testEffects, file, row.names = FALSE)\n      },\n      contentType = \"text/csv\"\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    ####################\n    # CHECK UPLOAD TAB #\n    ####################\n\n    # Functions that render the data files and pass them to ui.R\n\n    output$checktable1 <- renderTable({\n      x <- input$parameterFile\n      y <- input$loadSession\n      tableValues <- cache$params\n      if (is.null(tableValues)) return(NULL)\n      head(tableValues, n=5)\n    }, rownames = TRUE)\n\n    output$checktable2 <- renderTable({\n      x <- input$costsFile\n      y <- input$loadSession\n      tableValues <- cache$costs\n      if (is.null(tableValues)) return(NULL)\n      head(tableValues, n=5)\n    }, rownames = TRUE)\n\n    output$checktable3 <- renderTable({\n      x <- input$effectsFile\n      y <- input$loadSession\n      tableValues <- cache$effects\n      if (is.null(tableValues)) return(NULL)\n      head(tableValues, n=5)\n    }, rownames = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    ###################\n    # PSA RESULTS TAB #\n    ###################\n\n\n    ### CE PLANE\n\n    # This function gets the parameter names\n    # The output is the checkbox list for the intervention for the CE plane\n    observe({\n      x <- input$costsFile\n      y <- input$loadSession\n      namesOptions <- cache$namesDecisions\n      updateRadioButtons(session, \"decisionOptionCE1\",\n                         choices = namesOptions, selected = namesOptions[2])\n    })\n\n    # The output is the checkbox list for the comparator for the CE plane\n    observe({\n      x <- input$costsFile\n      y <- input$loadSession\n      namesOptions <- cache$namesDecisions\n      updateRadioButtons(session, \"decisionOptionCE0\",\n                         choices = namesOptions, selected = namesOptions[1])\n    })\n\n\n\n    # if the ind sim flag is set and the cache$modelledCosts is still null\n    # then get the modelled costs and effects\n    observe({\n      # cache$indSim <- input$indSim\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#       if (input$indSim == \"Yes\") {\n#         if (is.null(cache$modelledCosts)) {\n#           getModelledCostsAndEffects(cache, session)\n#         }\n#         cache$costs <- cache$modelledCosts\n#         cache$effects <- cache$modelledEffects\n#       } else {\n        cache$costs <- cache$uploadedCosts\n        cache$effects <- cache$uploadedEffects\n#      }\n    })\n\n\n    # CE plane\n    output$plots1 <- renderPlot({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#     cache$indSim <- input$indSim # ensure update with ind sim box tick / untick\n      cache$lambdaOverall <- input$lambdaOverall\n      costs <- cache$costs\n      effects <- cache$effects\n      makeCEPlanePlot(costs, effects,\n                      lambda=input$lambdaOverall, input$decisionOptionCE1,\n                      input$decisionOptionCE0, cache)\n    })\n\n\n    # Functions that make reactive text to accompany plots\n    output$textCEplane1 <- renderText({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      cache$pCostsavingVal <- pCostsaving(cache$costs, input$decisionOptionCE1,\n                input$decisionOptionCE0, cache)\n      cache$incValueCosts <- incValue(cache$costs, input$decisionOptionCE1,\n               input$decisionOptionCE0, cache)\n\n      cache$confIntCE025costs <- confIntCE(cache$costs, input$decisionOptionCE1,\n                                             input$decisionOptionCE0, 0.025, cache)\n\n      cache$confIntCE975costs <- confIntCE(cache$costs, input$decisionOptionCE1,\n                                             input$decisionOptionCE0, 0.975, cache)\n\n      cache$moreLessCosts <- moreLess(cache$costs, input$decisionOptionCE1,\n               input$decisionOptionCE0, cache)\n\n      cache$textCEplane1 <- paste(\"The figure above shows the (standardised)\n                                  cost-effectiveness plane based on the \",\n            cache$nIterate, \" model runs in the probabilistic sensitivity analysis.\n              The willingness-to-pay threshold is shown as a 45 degree line.\n            The mean incremental cost of \", input$decisionOptionCE1, \" versus \",\n              input$decisionOptionCE0,\" is \",\n            input$currency, cache$incValueCosts, \". This suggests that \",\n            input$decisionOptionCE1, \" is \",\n            cache$moreLessCosts, \" costly.\n              The incremental cost is uncertain because the model parameters are uncertain.\n            The 95% credible interval for the incremental cost ranges from \",\n              input$currency, cache$confIntCE025costs,\" to \",\n             input$currency, cache$confIntCE975costs,\". The probability that \",\n             input$decisionOptionCE1, \" is cost\n            saving compared to \", input$decisionOptionCE0,\" is \",\n            cache$pCostsavingVal, \".\", sep=\"\")\n\n      cache$textCEplane1\n    })\n\n    output$textCEplane2 <- renderText({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      cache$incValueEffects <- incValue(cache$effects, input$decisionOptionCE1,\n                input$decisionOptionCE0, cache)\n\n      cache$confIntCE025effects <- confIntCE(cache$effects, input$decisionOptionCE1,\n                input$decisionOptionCE0, 0.025, cache)\n\n      cache$confIntCE975effects <- confIntCE(cache$effects, input$decisionOptionCE1,\n                input$decisionOptionCE0, 0.975, cache)\n\n      cache$pMorebenVal <- pMoreben(cache$effects, input$decisionOptionCE1,\n                input$decisionOptionCE0, cache)\n\n      cache$moreLessEffects <- moreLess(cache$effects, input$decisionOptionCE1,\n                input$decisionOptionCE0, cache)\n\n      paste(\"The mean incremental benefit of \", input$decisionOptionCE1, \" versus \",\n            input$decisionOptionCE0, \" is \",\n            cache$incValueEffects,\n            \" \",input$unitBens, \"s.  This suggests that \", input$decisionOptionCE1,\" is \",\n            cache$moreLessEffects,\n              \" beneficial. Again, there is uncertainty in the incremental benefit\n            due to uncertainty in the model parameters. The 95%\n            credible interval for the incremental benefit ranges from \",\n            cache$confIntCE025effects, \" \", input$unitBens, \"s to \",\n            cache$confIntCE975effects, \" \",\n            input$unitBens,\"s. The probability that \", input$decisionOptionCE1,\n            \" is more beneficial than \", input$decisionOptionCE0, \" is \",\n            cache$pMorebenVal, \".\", sep=\"\")\n    })\n\n    output$textCEplane3 <- renderText({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      cache$pCEVal <- pCE(input$decisionOptionCE1, input$decisionOptionCE0,\n          input$lambdaOverall, cache)\n\n      cache$iCERVal <- iCER(cache$costs,\n          cache$effects, input$decisionOptionCE1, input$decisionOptionCE0, cache)\n\n      paste(\"The expected incremental cost per \", input$unitBens,\" (ICER) is estimated at \",\n            input$currency, cache$iCERVal,\n            \". There is a probability of \", cache$pCEVal,\n            \" that \", input$decisionOptionCE1, \" is more cost-effective than \",\n            input$decisionOptionCE0, \" at a threshold of \",\n            input$currency, input$lambdaOverall,\" per \",input$unitBens, sep=\"\")\n    })\n\n    output$textCEplane4 <- renderText({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n      paste(input$decisionOptionCE1, \"versus\", input$decisionOptionCE0)\n    })\n\n\n\n    # Table of Key Cost-Effectiveness Statistics\n    output$tableCEplane <- renderTable({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      tableCEplane <- makeTableCePlane(lambda=input$lambdaOverall, input$decisionOptionCE0, cache)\n      cache$lambdaOverall <- input$lambdaOverall\n      rownames(tableCEplane) <- c(paste(\"Threshold (\", input$currency, \" per \", input$unitBens, \")\", sep=\"\"),\n                                  \"Comparator\",\n                                  \"Number of PSA runs\",\n                                  paste(\"Mean inc. Effect per Person (\", input$unitBens, \")\", sep=\"\"),\n                                  paste(\"Mean inc. Cost per Person (\", input$currency, \")\", sep=\"\"),\n                                  paste(\"Mean inc. Net Benefit per Person (\", input$currency, \")\", sep=\"\"),\n                                  paste(\"ICER Estimate (\", input$currency, \" per \", input$unitBens, \")\", sep=\"\"),\n                                  paste(\"2.5th centile for inc. Effects (\", input$unitBens, \")\", sep=\"\"),\n                                  paste(\"97.5th centile for inc. Effects (\", input$unitBens, \")\", sep=\"\"),\n                                  paste(\"2.5th centile for inc. Costs (\", input$currency, \")\", sep=\"\"),\n                                  paste(\"97.5th centile for inc. Costs (\", input$currency, \")\", sep=\"\"),\n                                  paste(\"2.5th centile for inc. Net Benefits (\", input$currency, \")\", sep=\"\"),\n                                  paste(\"97.5th centile for inc. Net Benefits (\", input$currency, \")\", sep=\"\"),\n                                  \"Probability intervention is cost saving\",\n                                  \"Probability intervention provides more benefit\",\n                                  \"Probability that intervention is cost-effective against comparator\")\n      cache$tableCEplane <- tableCEplane\n      tableCEplane\n    }, rownames = TRUE)\n\n    # Download table as a csv file\n    output$downloadTableCEplane <- downloadHandler(\n\n      filename = \"Cost-Effectiveness\\ Statistics.csv\",\n      content = function(file) {\n        tableOut <- cache$tableCEplane\n        if(!is.null(cache$tableCEplane)) {\n          tableOut <- cbind(rownames(tableOut), tableOut)\n          colnames(tableOut) <- c(\"Intervention\", colnames(tableOut)[-1])\n        }\n        write.csv(tableOut, file, row.names = FALSE)\n      },\n      contentType = \"text/csv\"\n    )\n\n\n\n    ### CEAC\n\n    # function that calculates ceac\n    ceac <- reactive({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n      makeCeac(cache$costs, cache$effects, input$lambdaOverall, session)\n    })\n\n    output$textCEAC1 <- renderText({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      cache$bestCEVal <- bestCE(cache$costs, cache$effects,\n             input$lambdaOverall, cache$nInt)\n\n      cache$highestpCE <- highestCE(cache$costs, cache$effects,\n                                    input$lambdaOverall)\n\n      paste(\"This graph shows the cost-effectiveness acceptability curve for the\n            comparison of strategies. The results show that at a threshold\n            value for cost-effectiveness of \",input$currency, input$lambdaOverall,\n            \" per \",input$unitBens,\" the strategy with the highest\n            probability of being most cost-effective is \", cache$bestCEVal,\n            \", with a probability of \", cache$highestpCE,\n            \". More details on how to interpret CEACs are available from the literature.\", sep=\"\")\n    })\n\n    # CEAC plot\n    output$plots2 <- renderPlot({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n      ceac.obj <- cache$ceac.obj <- ceac()\n      cache$lambdaOverall <- input$lambdaOverall\n      makeCeacPlot(ceac.obj, lambda=input$lambdaOverall,\n                   names=colnames(cache$costs))\n    })\n\n\n\n   ### NET BENEFIT\n\n    output$textNB1 <- renderText({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      paste(\"Net benefit is a calculation that puts \", input$costDef, \" and \",\n        input$effectDef, \" onto the same scale.  This is done by calculating\n           the monetary value of \", input$effectDef, \" using a simple multiplication i.e. \",\n        input$unitBens, \"s * lambda, where:\", sep=\"\")\n    })\n\n    output$textNB2 <- renderText({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n      paste(\"Net benefit for a strategy = \", input$unitBens, \"s * \", input$lambdaOverall,\n            \" - Cost (\" ,input$currency, \").\", sep=\"\")\n    })\n\n    output$textNB3 <- renderText({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      cache$bestnetBenVal <- bestnetBen(cache$costs,\n                 cache$effects, input$lambdaOverall, cache$nInt)\n\n      cache$netBencostsVal <- netBencosts(cache$costs, cache$effects,\n                  input$lambdaOverall, cache$nInt)\n\n      cache$netBeneffectsVal <- netBeneffects(cache$costs, cache$effects,\n                    input$lambdaOverall, cache$nInt)\n\n      paste(\"The plot below shows the expected net benefit of the \", cache$nInt,\n            \" strategies, together with the 95% credible\n            interval for each one.  The strategy with highest expected net benefit is \",\n            cache$bestnetBenVal, \", with an expected net benefit of\n           \", input$currency, cache$netBencostsVal,\n           \" (equivalent to a net benefit on the effectiveness scale of \",\n           cache$netBeneffectsVal, \" \", input$unitBens, \"s).\n                Net benefit and 95% credible intervals for all strategies\n           are presented in the above table. \", sep=\"\")\n    })\n\n    # Table of Summary of Absolute Net Benefit Statistics\n    output$tableNetBenefit <- renderTable({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      tableNetBenefit <- makeTableNetBenefit(cache$costs, cache$effects,\n                                             lambda=input$lambdaOverall, cache$nInt)\n      cache$lambdaOverall <- input$lambdaOverall\n      rownames(tableNetBenefit) <- c(paste(\"Mean\", input$effectDef),\n                                    paste(\"Mean\", input$costDef),\n                                    paste(\"Expected Net Benefit at\",\n                                          input$currency, input$lambdaOverall,\n                                          \"per\", input$unitBens),\n                                    \"95% Lower CI (on Costs Scale)\",\n                                    \"95% Upper CI (on Costs Scale)\",\n                                    \"Expected Net Benefit on Effects Scale\",\n                                    \"95% Lower CI (on Effects Scale)\",\n                                    \"95% Upper CI (on Effects Scale)\")\n      cache$tableNetBenefit <- tableNetBenefit\n      tableNetBenefit\n    }, rownames = TRUE)\n\n    # Download table as a csv file\n    output$downloadTableNetBenefit <- downloadHandler(\n      filename = \"Net\\ benefit\\ statistics.csv\",\n      content = function(file) {\n        tableOut <- cache$tableNetBenefit\n        if(!is.null(tableOut)) {\n          tableOut <- cbind(rownames(tableOut), tableOut)\n          colnames(tableOut) <- c(\"Intervention\", colnames(tableOut)[-1])\n        }\n        write.csv(tableOut, file, row.names = FALSE)\n      },\n      contentType = \"text/csv\"\n    )\n\n    # EVPI INB bar plot\n    output$plots5a <- renderPlot({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      makeInbOptBar(cache$costs, cache$effects,\n                   lambda=input$lambdaOverall)\n    })\n\n    # Absolute net benefit densities\n    output$plots5 <- renderPlot({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      make2wayDensity(cache$costs, cache$effects,\n                     lambda=input$lambdaOverall)\n    })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n   ############\n   # EVPI TAB #\n   ############\n\n\n\n   output$textEVPI1 <- renderText({\n     if (!valuesImportedFLAG(cache, input)) return(NULL)\n#     dummy <- input$indSim # ensure update with ind sim box tick\n\n     paste(\"The overall EVPI per person affected by the decision is estimated to be \",\n           input$currency, format(calcEvpi(cache$costs,\n          cache$effects, input$lambdaOverall), digits = 4, nsmall=2), \".  This is equivalent to \",\n          format(calcEvpi(cache$costs, cache$effects, input$lambdaOverall)/input$lambdaOverall,\n                 digits = 4, nsmall=1), \" \", input$unitBens,\n          \"s per person on the health effects scale.\", sep=\"\")\n   })\n\n    output$textEVPI2 <- renderText({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      cache$calcEvpiVal <- calcEvpi(cache$costs, cache$effects, input$lambdaOverall)\n\n      paste(\"If the number of people affected by the decision per year is \" ,\n            input$annualPrev, \", then the overall EVPI per year is \", input$currency,\n            format(cache$calcEvpiVal * input$annualPrev,\n              digits = 4, nsmall=2), \" for \", input$jurisdiction, \".\", sep=\"\")\n    })\n\n    output$textEVPI3 <- renderText({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      paste(\"When thinking about the overall expected value of removing decision uncertainty,\n            one needs to consider how long the current comparison\n            will remain relevant. If the decision relevance horizon is \", input$horizon,\n            \" years, then the overall expected value of removing\n            decision uncertainty for \",\n            input$jurisdiction, \" would be \", input$currency,\n            format(cache$calcEvpiVal * input$annualPrev * input$horizon,\n            \tdigits = 4, nsmall=2),\".\", sep=\"\")\n    })\n\n    output$textEVPI4 <- renderText({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      paste(\"Research or data collection exercises costing more than this amount\n            would not be considered an efficient use of resources. This is because\n            the return on investment from the research – as measured by the\n            health gain and cost savings resulting from enabling the decision maker to better\n            identify the best decision  option – is expected to be no higher than \",\n            input$currency,\n            format(cache$calcEvpiVal * input$annualPrev * input$horizon,\n              digits = 4, nsmall=2),\".\", sep=\"\")\n      })\n\n    output$textEVPI5 <- renderText({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n\n      paste(\"The EVPI estimates in the table below quantify the expected value to\n            decision makers within \", input$jurisdiction, \" of removing all current\n            decision uncertainty at a threshold of \", input$currency, input$lambdaOverall,\n            \" per \", input$unitBens, \".  This will enable comparison against\n            previous analyses to provide an idea of the scale of decision uncertainty\n            in this topic compared with other previous decisions. The EVPI estimate\n            for a range of willingness-to-pay thresholds are illustrated in\n            the figures below the table.\", sep=\"\")\n    })\n\n\n    # Table Overall EVPI\n    output$tableEVPI <- renderTable({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy1 <- input$indSim # ensure update with ind sim box tick\n      dummy2 <- input$lambdaOverall\n\n      tableEVPI <- matrix(NA, nrow = 7, ncol = 2)\n      colnames(tableEVPI) <- c(paste(\"Overall EVPI (\",\n                                     input$currency, \")\", sep=\"\"),\n                               paste(\"Overall EVPI (\", input$unitBens, \")\", sep=\"\"))\n      rownames(tableEVPI) <- c(\"Per Person Affected by the Decision\",\n                              paste(\"Per Year in\", input$jurisdiction, \"Assuming\",\n                                    input$annualPrev, \"Persons Affected per Year\"),\n                              \"Over 5 Years\",\n                              \"Over 10 Years\",\n                              \"Over 15 Years\",\n                              \"Over 20 years\",\n                              paste(\"Over Specified Decision Relevance Horizon (\",\n                                    input$horizon, \" years)\", sep=\"\"))\n      overallEvpi <- calcEvpi(cache$costs, cache$effects,\n                                           lambda=input$lambdaOverall)\n      cache$overallEvpi <- overallEvpi\n      cache$lambdaOverall <- input$lambdaOverall\n      evpiVector <- c(overallEvpi, overallEvpi * input$annualPrev, overallEvpi * input$annualPrev * 5,\n                     overallEvpi * input$annualPrev * 10, overallEvpi * input$annualPrev * 15,\n                     overallEvpi * input$annualPrev * 20,\n                     overallEvpi * input$annualPrev * input$horizon)\n      tableEVPI[, 1] <- signif(evpiVector, 4)\n      tableEVPI[, 2] <- signif(evpiVector / input$lambdaOverall, 4)\n      cache$tableEVPI <- tableEVPI\n      tableEVPI\n    }, rownames = TRUE, digits=cbind(rep(0, 7), rep(0, 7), rep(2, 7)))\n\n    output$downloadTableEVPI <- downloadHandler(\n      filename = \"Overall\\ EVPI.csv\",\n      content = function(file) {\n        tableOut <- cache$tableEVPI\n        write.csv(tableOut, file)#, row.names = FALSE)\n      },\n      contentType = \"text/csv\"\n    )\n\n\n\n    # EVPI versus lambda (costs)\n    output$plots3 <- renderPlot({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      cache$lambdaOverall <- input$lambdaOverall\n      makeEvpiPlot(cache$costs, cache$effects, lambda=input$lambdaOverall,\n                   main=input$main3,\n                   xlab=\"Threshold willingness to pay\",\n                   ylab=\"Overall EVPI per person affected (on costs scale)\",\n                   col=\"blue\",  costscale = TRUE, session)\n    })\n\n    # EVPI versus lambda (effects)\n    output$plots4 <- renderPlot({\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n      makeEvpiPlot(cache$costs, cache$effects, lambda=input$lambdaOverall,\n                   main=input$main4,\n                   xlab=\"Threshold willingness to pay\",\n                   ylab=\"Overall EVPI per person affected (on effects scale)\",\n                   col=\"blue\",  costscale = FALSE, session)\n    })\n\n    output$plots6 <- renderPlot({\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n      make4wayEvpiPlot(cache$costs, cache$effects, lambda=input$lambdaOverall,\n                       prevalence=input$annualPrev, horizon=input$horizon,\n                       measure1 = input$currency,\n                       measure2 = input$unitBens, session)\n    })\n\n\n\n\n\n\n\n\n\n\n    ###############################\n    # EVPPI SINGLE PARAMETERS TAB #\n    ###############################\n\n    output$tableEVPPI <- renderTable({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n      lambda <- input$lambdaOverall # re-run if labmda changes\n#      dummy <- input$indSim # ensure update with ind sim box tick\n\n      cache$lambdaOverall <- input$lambdaOverall\n      params <- cache$params\n      costs <- cache$costs\n      effects <- cache$effects\n\n      overallEvpi <- calcEvpi(costs, effects, lambda)\n      cache$overallEvpi <- overallEvpi\n\n      inb <- createInb(costs, effects, lambda)\n      pEVPI <- applyCalcSingleParamGam(params, inb, session, cache)\n      cache$pEVPI <- pEVPI\n\n      tableEVPPI <- matrix(NA, nrow = ncol(params), ncol = 5)\n      tableEVPPI[, 1] <- round(pEVPI[, 1], 2)\n      tableEVPPI[, 2] <- round(pEVPI[, 2], 2)\n      tableEVPPI[, 3] <- round(pEVPI[, 1] / overallEvpi , 2)\n      tableEVPPI[, 4] <- signif(pEVPI[, 1] * input$annualPrev, 4)\n      tableEVPPI[, 5] <- signif(pEVPI[, 1] * input$annualPrev * input$horizon, 4)\n      colnames(tableEVPPI) <- c(paste(\"Per Person EVPPI (\", input$currency, \")\", sep=\"\"),\n                                \"Standard Error\",\"Indexed to Overall EVPI = 1.00\",\n                                paste(\"EVPPI for \", input$jurisdiction,\n                                      \" Per Year (\", input$currency, \")\", sep=\"\"),\n                                paste(\"EVPPI for \", input$jurisdiction, \" over \",\n                                      input$horizon, \" years (\", input$currency, \")\", sep=\"\"))\n      rownames(tableEVPPI) <- colnames(cache$params)\n      cache$tableEVPPI <- tableEVPPI\n      tableEVPPI\n    }, rownames = TRUE)\n\n    # Download single parameter EVPPI values as csv file\n    output$downloadSingleEVPPI <- downloadHandler(\n    filename = \"EVPPI\\ for\\ individual\\ parameters.csv\",\n      content = function(file) {\n        write.csv(cache$tableEVPPI, file)\n      },\n    contentType = \"text/csv\"\n    )\n\n\n    # EVPPi horizontal bar chart\n    output$plot7 <- renderPlot({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n      dummy <- input$lambdaOverall\n      makeEvppiBar(cache$pEVPI[, 1], cache$params)\n    })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    ################\n    # EVPPI GROUPS #\n    ################\n\n    # This function gets the parameter names\n    # The output is the checkbox list\n    observe({\n      x <- input$parameterFile\n      y <- input$loadSession\n      params <- cache$params\n      if (is.null(params)) return(NULL)\n      namesParams <- colnames(params)\n      namesParams <- paste(1:ncol(params), \") \", namesParams, sep=\"\")\n      updateCheckboxGroupInput(session, \"pevpiParameters\",\n                               choices = namesParams)\n    })\n\n\n    # These functions take the user input groups, call the partial EVPI (for groups) functions\n    # and then output the results.\n\n    # This function gets the selection and assigns it to cache\n    observe({\n      currentSelectionNames <- input$pevpiParameters\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n      params <- cache$params\n      if (is.null(params)) return(NULL)\n      paramNames <- paste(1:ncol(params), \") \", colnames(params), sep=\"\")\n      currentSelection <- which(paramNames%in%currentSelectionNames)\n      cache$currentSelection <- currentSelection\n    })\n\n    # This function responds to the add button being pressed\n    # This function saves the current selection and then increase counter\n    # It does the calculation and then outputs the selection table\n    output$selectedTable <- renderTable({\n      dummy <- input$calculateSubsetsEvpi\n      if (dummy == 0) return(NULL)\n      if (!isolate(valuesImportedFLAG(cache, input))) return(NULL)\n      if (dummy == 0) return(NULL)\n\n      counterAdd <- cache$counterAdd\n      counterAdd <- counterAdd + 1\n      cache$counterAdd <- counterAdd\n\n      setStore <- cache$setStore\n      currentSelection <- cache$currentSelection\n      setStore[[counterAdd]] <- currentSelection\n      cache$setStore <- setStore\n\n      calc <- function(x, inp, cache, session) { # pass session so the progress bar will work\n        calSubsetEvpi(x, inp, cache, session)\n      }\n\n      #first pull down the existing values\n      subsetEvpiValues <- cache$subsetEvpiValues\n      if (is.null(subsetEvpiValues)) {\n        subsetEvpiValues <- t(sapply(setStore[1:counterAdd], calc,\n                                input$lambdaOverall, cache, session))\n      } else {\n        newEvpiValue <- t(sapply(setStore[(NROW(subsetEvpiValues) + 1):counterAdd],\n                                 calc, input$lambdaOverall, cache, session))\n        subsetEvpiValues <- rbind(subsetEvpiValues, newEvpiValue)\n      }\n\n      cache$subsetEvpiValues <- subsetEvpiValues\n      cache$setStoreMatchEvpiValues <- setStore # cache these for the report in case they change\n\n      cache$groupTable <- buildSetStoreTable(setStore[1:counterAdd], subsetEvpiValues, cache)\n      cache$groupTable\n    }, rownames = TRUE, sanitize.rownames.function = bold.allrows)\n\n    # Download group EVPPI values as csv file\n    output$downloadGroupEVPPI <- downloadHandler(\n      filename = \"EVPPI\\ for\\ parameter\\ groups.csv\",\n      content = function(file) {\n        contents <- cache$groupTable\n        if(!is.null(contents)) {\n          contents[, 1] <- as.character(contents[, 1])\n          print(contents <- as.matrix(contents))\n          colnames(contents) <- c(\"Parameters\",\n            paste(\"Per Person EVPPI (\", cache$currency, \")\", sep=\"\"),\n            \"Standard Error\",\n            \"Indexed to Overall EVPI\",\n            paste(\"EVPPI for \", cache$jurisdiction,\n              \" Per Year (\", cache$currency, \")\", sep=\"\"),\n            paste(\"EVPPI for \", cache$jurisdiction,\n              \" over \", cache$horizon, \" years (\", cache$currency, \")\", sep=\"\"))\n        }\n        write.csv(contents, file)\n      },\n      contentType = \"text/csv\"\n    )\n\n\n     # This clears everything on loading new data.\n    observe({ # clear the selections\n      # dummy <- input$clearSubsetsEvpi\n      dummy1 <- valuesImportedFLAG(cache, input)\n      setStore <- vector(\"list\", 100)\n      cache$setStore <- setStore\n      cache$counterAdd <- 0\n      cache$subsetEvpiValues <- NULL\n      cache$setStoreMatchEvpiValues <- NULL # cache these for the report in case they change\n    })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    ############\n    # PSUB TAB #\n    ############\n\n    output$tablePSUB <- renderTable({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n      #      dummy1 <- input$indSim # ensure update with ind sim box tick\n      dummy2 <- input$lambdaOverall\n\n      tablePSUB <- matrix(NA, nrow = 3, ncol = cache$nInt)\n\n      cache$lambdaOverall <- input$lambdaOverall\n      .nb <- colMeans(createNb(cache$costs, cache$effects, cache$lambdaOverall))\n      psb <- as.numeric(max(.nb) - .nb)\n\n      overallEvpi <- calcEvpi(cache$costs, cache$effects, cache$lambdaOverall)\n\n      tablePSUB[1, ] <- signif(psb, 4)\n      tablePSUB[2, ] <- signif(overallEvpi, 4)\n      tablePSUB[3, ] <- signif(psb + overallEvpi, 4)\n\n\n      colnames(tablePSUB) <- colnames(cache$costs)\n      rownames(tablePSUB) <- c(\"Payer Strategy Burdens\",\"Payer Uncertainty Burdens\",\"P-SUBS\")\n\n      cache$tablePSUB <- tablePSUB\n      tablePSUB\n    }, rownames = TRUE)\n\n\n\n    output$downloadTablePSUB <- downloadHandler(\n      filename = \"PSUB.csv\",\n      content = function(file) {\n        tableOut <- cache$tablePSUB\n        write.csv(tableOut, file)#, row.names = FALSE)\n      },\n      contentType = \"text/csv\"\n    )\n\n\n\n    output$plotsPSUBstacked <- renderPlot({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n      makePSUBplot(cache$costs, cache$effects, lambda=input$lambdaOverall, input$annualPrev, benUnit = input$unitBens,\n                   beside = FALSE)\n    })\n\n\n    output$plotsPSUBsideBySide <- renderPlot({\n      if (!valuesImportedFLAG(cache, input)) return(NULL)\n      makePSUBplot(cache$costs, cache$effects, lambda=input$lambdaOverall, input$annualPrev, benUnit = input$unitBens,\n                   beside = TRUE)\n    })\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    ################\n    # EVSI TAB     #\n    ################  \n\n    # This function gets the parameter names\n    # The outputs are the checkboxes lists\n    observe({     \n      x <- input$parameterFile\n      y <- input$loadSession\n      params <- cache$params\n      \n      if (is.null(cache$psaSampleList)) \n        return(NULL)\n      \n      parametersNames <- cache$psaSampleList$getPsaSampleNames()\n      scenarioFriendlyNames <- cache$scenarioList$getScenariosFriendlyNames()\n      \n      updateSelectInput(session, \"likelihood.psa.new.sample\", \n                        choices = scenarioFriendlyNames)\n      \n  \n      })\n   \n    # output$has.no.parameters <- reactive({\n    #   return(valuesImportedFLAG)\n    # })\n    # \n    # outputOptions(output, \"has.no.parameters\", suspendWhenHidden = FALSE);\n    \n    \n    # Event when user add a likelihood distribution to a scenario. \n    observeEvent(input$likelihood.psa.new.sample, {\n\n      if(input$likelihood.psa.new.sample!=\"\"){\n        \n        if(!is.null(cache$scenarioController)){\n          cache$scenarioController$clearScenario(cache, input, output)\n        }else{\n          # If no scenario exists, create one and initialise the error ractiveValue.  \n          cache$scenarioController <- ScenarioController$new()\n        }\n        \n        cache$scenarioController$errorMsg <- reactiveValues()\n        cache$scenarioController$errorMsg$text <- \"\"\n        output[[\"likelihood.psa.new.sample.error.message\"]]<-reactive({\n          cache$scenarioController$errorMsg$text \n        })\n        \n        # Set the selected Scenario\n        selectedScenario <- cache$scenarioList$getScenarioWithFriendlyName(input$likelihood.psa.new.sample)\n        cache$scenarioController$setScenario(selectedScenario, cache, input, output)\n        \n        # Load text in frontend\n        output$scenarioName <-  renderUI({\n          selectedScenario$getFriendlyName()\n        })\n        output$scenarioDescriptionLatex <-  renderUI({\n          HTML(paste0( selectedScenario$getDescriptionLatex() ,\"<script>if (window.MathJax) MathJax.Hub.Queue(['Typeset', MathJax.Hub]);</script>\"))\n        })\n      }\n    })\n    \n  \n    # Event when user click on \"calculate EVSI\" button.  \n    observeEvent(input$likelihood.psa.new.sample.calculate.evsi, {\n      # Set error message empty\n      cache$scenarioController$errorMsg$text <- \"\"\n      \n      # Check that a scenario exists and that there are ate least one likelihood\n      if (!is.null(cache$scenarioController)) {\n        \n        # Check that no parameters errors exist (string is empty)\n        if(cache$scenarioController$getErrorMsg()!=\"\"){\n          cache$scenarioController$errorMsg$text <- \"correct parameters errors first\"\n        }else{\n          \n          # extract the sample sizes of trials to be simulated. \n          evsi.size.start     <- input$likelihood.psa.new.sample.size.start\n          evsi.size.end       <- input$likelihood.psa.new.sample.size.end\n          evsi.size.step      <- input$likelihood.psa.new.sample.size.step\n          # Get the amount of replication in PSA samp,e to reduce SE\n          evsi.replications     <- input$likelihood.psa.new.sample.replication\n          \n          # Listen for error! \n            \n          tryCatch({\n\n            # Generate sample size vector\n            nsample <- round(seq(from = evsi.size.start, to = evsi.size.end, length.out = evsi.size.step))\n            \n            # Calculate EVSI for scenario \n            evsi.results <- cache$scenarioController$calculateEVSI(session, cache, input, nsample, evsi.replications)\n            \n            # Name evsi matrix's columns and render. \n            colnames(evsi.results) <- c(\"Sample Size\", \"EVSI\", \"SE\")\n            \n            # Display Sample size, EVSI and Standard error in a table \n            output$tableEVSI <- renderTable({\n              evsi.results\n            })\n            \n            # Display EVSI in a plot\n            output$plotEVSI <- renderPlotly({\n              lambda <- input$lambdaOverall # re-run if labmda changes\n              f <- list(\n                family = \"Courier New, monospace\",\n                size = 18,\n                color = \"#7f7f7f\"\n              )\n              x <- list(\n                title = \"sample size\",\n                titlefont = f\n              )\n              y <- list(\n                title = \"EVSI (£)\",\n                titlefont = f\n              )\n              plot_ly(x = evsi.results[, \"Sample Size\"], y = evsi.results[, \"EVSI\"], type = 'scatter', mode = 'markers+lines') %>%\n                layout(\n                  xaxis=x,yaxis=y)\n            })\n         },\n          # In case of error, display an error message\n          error = function(e){\n            if(grepl(\"has insufficient unique values to support\", e$message)){\n              cache$scenarioController$errorMsg$text <- \"Not enough distinct generated values. (try to increase the starting sample size)\"\n            }else if(grepl(\"cerr:\", e$message)){\n              cache$scenarioController$errorMsg$text <- gsub(\"cerr:\", \"\", e$message)\n            }else{\n              cache$scenarioController$errorMsg$text <- e$message #\"Unknwon warning\"\n            }\n            \n          })\n        }\n        \n      }else{\n        cache$scenarioController$errorMsg$text <- \"No Scenario selected!\"\n      }\n    })\n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    #################\n    # REPORT TAB #\n    #################\n\n    ## DOWNLOAD REPORT conditional on Pandoc installation\n\n    output$pandoc <- reactive(pandoc_available())\n    outputOptions(output, \"pandoc\", suspendWhenHidden=FALSE)\n\n    output$downloadReport <- downloadHandler(\n      filename = function() {\n        paste('my-report', sep = '.', switch(\n          input$format, HTML = 'html', Word = 'docx'\n        ))\n      },\n\n      content = function(file) {\n        src <- normalizePath('report.Rmd') # template report\n        # temporarily switch to the temp dir\n\n        oldwd <- setwd(tempdir())\n        on.exit(setwd(oldwd))\n        file.copy(src, 'report.Rmd', overwrite=TRUE)\n\n        library(rmarkdown)\n        out <- render(input = 'report.Rmd', #pdf_document()\n                      output_format = switch(\n                        input$format,\n                        HTML = html_document(),\n                        Word = word_document()),\n                      envir = cache\n        )\n        file.copy(out, file)\n      },\n      contentType = \"text/plain\"\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}) # END OF SHINYSERVER FUNCTION\n\n\n######################################################## ENDS #############################################\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1523048365092.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3089969847",
    "id" : "335E5B66",
    "lastKnownWriteTime" : 1523048850,
    "last_content_update" : 1523048850781,
    "path" : "C:/R_SAVI/riskTab_version/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}