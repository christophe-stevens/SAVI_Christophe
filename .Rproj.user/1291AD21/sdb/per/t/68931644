{
    "collab_server" : "",
    "contents" : "\nScenarioController  <- R6Class(\"scenarioController\", public= list(\n                                                errorMsg =\"\", \n                                                getErrorMsg = function(){\n                                                  # Get errors that exists for the input values of likelihood \n                                                  # distribution parameters. \n                                                  #\n                                                  # Returns:\n                                                  #   String, return a comma separated string of errors\n                                                  return(private$scenario$getErrorMsg())\n                                                },\n                                                setScenario = function(scenario, cache, input, output){\n                                                    private$scenario <- scenario$clone(TRUE)\n                                                    private$drawScenario(cache, input, output)\n                                                },\n                                                clearScenario = function(cache, input, output){\n                                                  # Remove all likelihood pane on the evsi calculator. \n                                                  #\n                                                  # Args:\n                                                  #   cache: all the objects stored for current user.\n                                                  #   input: Input object to listen to the view.\n                                                  #   output: Output object list to manipulate view.\n                                                  #\n                                                  # Returns:\n                                                  #   void, doesn't return anything, it remove a likelihood from the screen\n                                                  removeUI(selector = paste(\"#\",private$scenario$getDomId(), sep=\"\"))\n                                                  private$scenario <- NULL\n                                                },\n                                                calculateEVSI = function(session, cache, input, nsample, replications){\n                                                   lambda <- input$lambdaOverall # re-run if labmda changes\n                                                   inb   <- createInb(cache$costs, cache$effects, lambda)\n                                                   \n                                                   N <- cache$psaSampleList$getMinRowCount() \n                                                   \n                                                   # Initialise result array to contain evsi estimation by sample size\n                                                   output.evsi.by.sample.size <- matrix(rep(length(nsample) * 3), ncol = 3, nrow = length(nsample))\n                                                   \n                                                   # Set Progress bar\n                                                   progress <- shiny::Progress$new(session, min = 1, max = length(nsample))\n                                                   on.exit(progress$close())\n                                                   progress$set(message = 'Calculation in progress',\n                                                                detail = 'Please wait...')\n                                                   \n                                                   # Replicate inb. \n                                                   inb <- inb[rep(seq_len(dim(inb)[1]), each=replications),]\n                                                   for ( curr.n in 1:length(nsample) )\n                                                   {\n                                                      SimulatedData <- private$simulate(N, nsample[curr.n], cache, replications)\n                                                      \n                                                      resultsForNs <- list()\n                                                      # Use GAM for fewer than 5 variables\n                                                      if(dim(SimulatedData)[2]<=4){\n                                                        resultsForNs <- private$calculateEVSIGAM(inb,SimulatedData, replications, N)\n                                                      }else{\n                                                        # use GP\n                                                        if(replications>1)\n                                                          stop(\"cerr: When more than 4 parameters are used, replications cannot be used. (due to matrix size)\")\n                                                        resultsForNs <- private$calculateEVSIGP(inb,SimulatedData, replications, N, session)\n                                                      }\n                                                      \n                                                      output.evsi.by.sample.size[curr.n, 1]<- nsample[curr.n]\n                                                      output.evsi.by.sample.size[curr.n, 2]<- resultsForNs$evsi\n                                                      output.evsi.by.sample.size[curr.n, 3]<-  resultsForNs$SE\n                                                      \n                                                      # Update user on progress \n                                                      progress$set(curr.n)\n                                                      \n                                                   }\n                                                   return(output.evsi.by.sample.size)\n                                                 }),\n                                private = list( scenario = NULL, \n                                                drawScenario = function(cache, input, output){\n                                                  # Insert a new likelihood pane on the evsi calculator. \n                                                  #\n                                                  # Args:\n                                                  #   cache: all the objects stored for current user.\n                                                  #   input: Input object to listen to the view.\n                                                  #   output: Output object list to manipulate view.\n                                                  #\n                                                  # Returns:\n                                                  #   void, doesn't return anything, it adds a likelihood to screen\n                                                  insertUI(selector = \"#scenario\",\n                                                           where = \"beforeEnd\",\n                                                           ui =  likelihoodControl(private$scenario, cache, input, output),\n                                                           immediate\t= T )\n                                                  output$has.likelihoods <- reactive({\n                                                    cache$scenarioController$hasScenario\n                                                  })\n                                                },\n                                                simulate = function(simSize,  size, cache, reps){\n                                                  # Assume only one likelihood by scenario\n                                                  simulatedMatrix <- private$scenario$simulate(simSize, size, cache, reps)\n                                                  simulatedMatrix  <- as.data.frame(simulatedMatrix )\n                                                  colnames(simulatedMatrix ) <- LETTERS[1:dim(simulatedMatrix)[2]]\n                                                  \n                                                  return(simulatedMatrix )\n                                                },\n                                                getGamFormulaForDataFrameNames =function(LikelihoodsNames){\n                                                  form <- paste(LikelihoodsNames, \",\", sep=\"\", collapse=\"\")\n                                                  form <- substr(form, 1, nchar(form) - 1)\n                                                  if (length(LikelihoodsNames) > 4 ) {\n                                                    form <- paste(\"te(\", form, \",k=-1)\", sep=\"\") # restrict to 4 knots if 4 params\n                                                  } else if (length(LikelihoodsNames) == 4 ) {\n                                                    form <- paste(\"te(\", form, \",k=4)\", sep=\"\") # restrict to 4 knots if 4 params\n                                                  } else {\n                                                    form <- paste(\"te(\", form, \")\", sep=\"\")    \n                                                  }\n                                                  return(form)\n                                                },\n                                                calculateEVSIGAM = function(inb, SimulatedData, replications, N){\n                                                  \n                                                  D <- ncol(inb)\n                                                  \n                                                  # Simulation size \n                                                  s <- 10^3\n                                                  \n                                                  \n                                                  g.hat <- beta.hat <- Xstar <- V <- tilde.g <- vector(\"list\", D)\n                                                  g.hat[[1]] <- 0\n                                                  \n                                                  \n                                                  regression.model <- private$getGamFormulaForDataFrameNames(colnames(SimulatedData))\n                                                  \n                                                  for( d in 2:D) {\n                                                    dependent <- inb[, d]\n                                                    \n                                                    data <- cbind(dependent, SimulatedData )\n                                                    \n                                                    f <- update(formula(dependent~.), formula(paste(\".~\", regression.model)))\n                                                    print(f)\n                                                    model <- gam(f, data = data)\n                                                    g.hat[[d]] <- model$fitted\n                                                    beta.hat[[d]] <- model$coef\n                                                    Xstar[[d]] <- predict(model,type=\"lpmatrix\")\n                                                    V[[d]] <- model$Vp\n                                                  }\n                                                  # Compute EVSI\n                                                  perfect.info <- mean(do.call(pmax, g.hat)) \n                                                  baseline <- max(unlist(lapply(g.hat, mean)))\n                                                  evsi <- perfect.info - baseline\n                                                  rm(g.hat); gc()\n                                                  \n                                                  \n                                                  for(d in 2:D) {\n                                                    sampled.coef <- mvrnorm(s, beta.hat[[d]], V[[d]])\n                                                    tilde.g[[d]] <- sampled.coef%*%t(Xstar[[d]])  \n                                                  }\n                                                  \n                                                  tilde.g[[1]] <- matrix(0, nrow = s, ncol = N * replications)\n                                                  rm(V, beta.hat, Xstar, sampled.coef);gc()\n                                                  \n                                                  sampled.perfect.info <- rowMeans(do.call(pmax, tilde.g))\n                                                  sampled.baseline <- do.call(pmax, lapply(tilde.g, rowMeans)) \n                                                  rm(tilde.g); gc()\n                                                  sampled.evsi <- sampled.perfect.info - sampled.baseline\n                                                  SE <- sd(sampled.evsi)\n                                                  print(sampled.evsi)\n                                                  return(list(evsi= evsi , SE=SE))\n                                                  \n                                                },\n                                                calculateEVSIGP = function(inb, SimulatedData, replications, N, session) {\n\n                                                  maxSample <- min(5000, nrow(inb)) # to avoid trying to invert huge matrix\n                                                  inb <- as.matrix(inb[1:maxSample, ])\n                                                  D <- ncol(inb)\n                                                  s <- 10^3\n                                                  \n                                                  input.matrix <- as.matrix(SimulatedData[1:maxSample, , drop=FALSE])\n                                                  colmin <- apply(input.matrix, 2, min)\n                                                  colmax <- apply(input.matrix, 2, max)\n                                                  colrange <- colmax - colmin\n                                                  input.matrix <- sweep(input.matrix, 2, colmin, \"-\")\n                                                  input.matrix <- sweep(input.matrix, 2, colrange, \"/\")\n                                                  N <- nrow(input.matrix)\n                                                  p <- ncol(input.matrix)\n                                                  H <- cbind(1, input.matrix)\n                                                  q <- ncol(H)\n                                                  \n                                                  \n                                                  \n                                                  m <- min(30 * p, 250)\n                                                  m <- min(nrow(inb), m)\n                                                  setForHyperparamEst <- 1:m # sample(1:N, m, replace=FALSE)\n                                                  hyperparameters <- estimate.hyperparameters(inb[setForHyperparamEst, ], \n                                                                                              input.matrix[setForHyperparamEst, ], session)\n                                                  \n                                                  V <- g.hat <- vector(\"list\", D)\n                                                  g.hat[[1]] <- rep(0, N)\n\n                                                  for(d in 2:D)\n                                                  {\n                                                    print(paste(\"estimating g.hat for incremental NB for option\", d, \"versus 1\"))\n                                                    delta.hat <- hyperparameters[[d]][1:p]\n                                                    nu.hat <- hyperparameters[[d]][p+1]\n                                                    A <- makeA.Gaussian(input.matrix, delta.hat)\n                                                    Astar <- A + nu.hat * diag(N)\n                                                    Astarinv <- chol2inv(chol(Astar))\n                                                    rm(Astar); gc()\n                                                    AstarinvY <- Astarinv %*% inb[, d]\n                                                    tHAstarinv <- t(H) %*% Astarinv\n                                                    tHAHinv <- solve(tHAstarinv %*% H + 1e-7* diag(q))\n                                                    betahat <- tHAHinv %*% (tHAstarinv %*% inb[, d])\n                                                    Hbetahat <- H %*% betahat\n                                                    resid <- inb[, d] - Hbetahat\n                                                    g.hat[[d]] <- Hbetahat+A %*% (Astarinv %*% resid)\n                                                    AAstarinvH <- A %*% t(tHAstarinv)\n                                                    sigmasqhat <- as.numeric(t(resid) %*% Astarinv %*% resid)/(N - q - 2)\n                                                    V[[d]] <- sigmasqhat*(nu.hat * diag(N) - nu.hat ^ 2 * Astarinv +\n                                                                            (H - AAstarinvH) %*% (tHAHinv %*% t(H - AAstarinvH)))\n                                                    rm(A, Astarinv, AstarinvY, tHAstarinv, tHAHinv, betahat, Hbetahat, resid, sigmasqhat);gc()\n                                                  }\n                                                  perfect.info <- mean(do.call(pmax, g.hat)) \n                                                  baseline <- max(unlist(lapply(g.hat, mean)))\n                                                  \n                                                  evsi <- perfect.info - baseline\n                                                  \n                                                  print(\"Computing standard error via Monte Carlo\")\n                                                  tilde.g <- vector(\"list\", D)\n                                                  tilde.g[[1]] <- matrix(0, nrow=s, ncol=N * replications)     \n                                                  \n                                                  \n                                                  for(d in 2:D) {\n                                                    tilde.g[[d]] <- mvrnorm(s, g.hat[[d]][1:(min(N, 1000))], V[[d]][1:(min(N, 1000)), 1:(min(N, 1000))])\n                                                  }\n                                                  \n                                                  sampled.perfect.info <- rowMeans(do.call(pmax, tilde.g))\n                                                  sampled.baseline <- do.call(pmax, lapply(tilde.g, rowMeans)) \n                                                  rm(tilde.g);gc()\n                                                  sampled.partial.evpi <- sampled.perfect.info - sampled.baseline\n                                                  SE <- sd(sampled.partial.evpi)\n\n                                                  rm(V, g.hat);gc()\n                                                  return(list(evsi=evsi, SE=SE))\n                                                  \n                                                })\n                    )\n",
    "created" : 1522957821819.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1475237212",
    "id" : "68931644",
    "lastKnownWriteTime" : 1523048844,
    "last_content_update" : 1523048844445,
    "path" : "C:/R_SAVI/riskTab_version/EVSI/scenarioController.R",
    "project_path" : "EVSI/scenarioController.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}